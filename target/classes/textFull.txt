The following content is provided under a Creative Commons license your support will help MIT, opencourseware continue to offer high-quality educational resources for free to make a donation or view additional materials from hundreds of MIT courses visit MIT opencourseware at ocw.mit.edu. Start a brand new exciting topics dynamic programming. So exciting actually, I'm really excited because then I forgot mine is my favorite thing in the world in algorithms and it's going to be the next four lectures. It's so exciting have lots of different facets. It's a very general powerful design technique a little while to settle in we we like to inject it into now and double o six so in general, Our motivation is designing new algorithms. Cinemax programming also called PP is a great way. a great General powerful way to do this It's especially good and intended for optimization problems things like shortest path. You want to find the best way to do something. So I just pass you want to find the shortest path the minimum length path. He want to minimize maximize something that's an optimization problem and typically go down to solve them involve dynamic programming of a broad statement think of dynamic programming as a kind of exhaustive search which is usually a bad thing to do because it leads to exponential time. But if you do it in a clever way by then you typically get polymer polynomial time. So one perspective is that dynamic programming is approximately careful Brute Force. Have an oxymoron. Are we take the idea of Brute Force which is try all possibilities and you do it carefully and you'll get it polynomial time there a lot of problems were essentially the only known polynomial time algorithm is by dynamic programming doesn't always work. There's some problems where we don't think there are. When is possible DPS a nicer General approach to it? And we're going to be talking a lot about that and I program a has a lot of different. There's a lot of different ways to think about it. We'll look at a few today. We're going to warm up today with some fairly easy problems that we already know how to solve namely Computing Fibonacci numbers pretty easy and Computing shortest pads. And then in the next three lectures were going to get some more interesting examples where that's pretty surprising that you can even solve the problem in polynomial time. Probably the first burning question on your mind though is why is it called dynamic programming? What does that even mean? And I used to have this feel about well, you know programming refers to the I think it's a British notion of the word where it's about optimization optimization in American English is something like programming in British English. I know you want to set up the program the schedule for your trains or something I think is where programming comes from originally but I looked at the actual history. Why is it called dynamic programming dynamic programming is invented by a guy named Richard Bellman. You may have heard of bellman be in the Bellman Ford algorithm. So this is actually the precursor to bellman-ford and we're going to seem bellman-ford come up naturally in the setting. So here's here's what I caught about him says Belmont explain that he invented the name dynamic-programming to hide the fact that he was doing mathematical research. He was working at this place called ranz and under a secretary of defense who had a pathological fear and hatred for the term research. So he said it would be difficult to give a pejorative meaning to it and because it was something not even a congressman could have ject to basically it sounded cool. So that's that's the origin of the name Diner, So why is it called that who knows? I mean now, you know, but it's not it's a weird term just take it for what it is. It may make sense some kind of sense. So we are going to start. with this example of how to compute Fibonacci numbers and maybe before we actually start I'm going to give you a sneak peek what you can think of dynamic programming is and This this equation. So to speak is going to change today's lecture and then we'll settle on a certain more accurate perspective. The basic idea of dynamic programming is to take a problem split into some problems solve the some problems and reuse the solutions to your problems. It's this like a lesson and recycling. So we'll see that in Fibonacci numbers. So you remember Fibonacci numbers? Number of rabbits you have on Day end if they reproduce. We've mentioned before we're talking about AVL trees. I think so. This is the usual I can think of it as a recursive definition or recurrence on Fibonacci numbers. The definition of what the ends Fibonacci number is. So let's suppose our goal and I'll grab my problem is compute the Fibonacci number. And I'm going to assume hear that that fits in a word and so basic arithmetic edition. Whatever is constant. I'm proper Asian, so How do we do it? You'll know how to do it anyways, but I'm going to give you the dynamic programming perspective on things. So this will seem kind of obvious but it is a we're going to apply exactly the same principles of will apply over and over in dynamic programming, but here it's in a very familiar. setting so we're going to start with the naive recursive algorithm. and that is if you want to come get the food and Fibonacci number you check whether you're in the base case. I'm going to write it this way. So f is just our return value you see why it's right at this way in a moment. Then you return a half face Kisses one. Otherwise you recursively call Fibonacci have in mind to add them together return that this is a correct algorithm. Did a good algorithm know very bad exponential time? How do we know it's exponential time other than from experience what we can write the running time as a recurrence? The event represents the time to commute the inside of an option number. How can I write the recurrence? It's throwback to the early lectures divide and conquer. Harrisburg Yeah. 7 - 1 + 7 - 2 constant I don't know how many you have by now and then we take constant. I'm otherwise we do council member of additions comparisons and return all these operations take on some time. So that's a recurrence. How do we solve this recurrence? Well one way is to see this is Fibonacci recurrence the same thing. This is plus whatever this is at least the number and if you know Fibonacci stuff, that's about the golden ratio to the nth power. Too bad. We had a similar recurrence in AVL trees. And so another way to solve it say oh, well, that's at least two times given -2 as it's going to be monotone. The bigger it is the more work you have to do because Davidians thing you have to do the first thing so we can just reduce 7 - 137 - 2 that will give us a lower bound and now these two term now this is sort of an easy thing. You see that you're multiplying by two each time. You're subtracting two from anytime. How many times can I subtract 2 from 10 and over 2 times before I get down to a constant. And so this is equal to 2 to the and over to I mean time some constant which is what you get in the base case. So I guess I should say. this thing is stated that SS at least that big and the right constant is a fee. the base the exponent Okay, so that's a bad. I'll go then we all know it's bad for them. But I'm going to give you a general approach for making bad over this like this good and that channel approach is called memorization. here and this is a technique of dynamic programming. I call this memorized dynamic programming algorithm. so I said I'm using memo in the nuts. That is simple. Whenever we compute a Fibonacci number, we put it in a dictionary if it's and then we need to compute the answer Bonacci number we check is it already in the dictionary that we already solve this problem? If so return that answer otherwise computer. I'll see the transformation is very simple. Okay, these two lines are identical to these two lines. So you can see how the transformation Works in general you can do this with any recursive algorithm. Memorization transformation on that algorithm. Just we initially make an empty dictionary Thug memo. And before we actually do the computation we say well check weather this this version of the Fibonacci problem competing at the van is already in our dictionary so that key is already in the dictionary. We return the corresponding value in the dictionary. So and then once we computed the answer, but I don't remember if we bother to do this if this didn't apply then we store it in the memo table. So we store we say well if you ever need to compete at the van again, here it is and then we return that value. I said this is a general procedure. Complete any recursive algorithm? With no side effects, I guess technically and turns out this makes the algorithm efficient now, there's a lot of ways to see why it's efficient. In general, maybe it's helpful to think about the recursion for you. So if you want to compute a fan in the old Al Gore then we compute + 10 - 1 - -2 completely separately to compute f n -1. We compute f n - 2 + f n - 3 to computer from my stupid computer is 3 and 10 - 4 and so on you can see why that's exponential and end cuz we're only decrementing and buy one or two each time. But then you observe hey these FN - 3 is are the same. I should really only have to compute the once. And that's what we're doing here. The first time you call f n - 3 you do work, but once it's done and you could over to this other recursive call, this will just get cut off. There's no tree here here. We might have some recursive calling here. We won't because it's already in the memo table. Pan factus RTM happens if + -2 this whole this whole tree disappears because if in - 2 is already been done. Concerts clear white improve things so you in fact you can you can argue that. This call will be free because you already did the work in here. But I want to give you a very particular way of thinking about why this is efficient. which is Towing so you could write down a recurrence for the running time here, but in some sense recurrences aren't quite the right way of thinking about this because recursion is kind of a rare thing if you're calling Fibonacci some value k You're only going to make recursive called the first time you call Fibonacci. Okay, because henceforth it's been the you put in the memo table, you will not reverse so you can think of there being two versions of calling Fibonacci. Okay, there's the first time which is the non memorize version that does recursion doesn't work. And then every time henceforth your you're doing menopause cause if not you can those cost constant. I'm Southern memorized calls Costco sometime so we can think of them as basically free. That when you call Fibonacci of N - 2 because that's a memorize call. It's you really doesn't pay anything for it. And we already paying Thompson time to do addition and whatever so you don't have to worry about the time is whenever corrosion here. And then what we care about is that the number of non memorize calls. Which is the first time you call Fibonacci, okay? and then No, they don't even necessary. We are going to call Fibonacci one some point. We're going to call Fibonacci have to at some point and the original call is Fibonacci have in all of those things will be called at some point. It's pretty easy to see but it's Chiklis certainly at most of this whenever call Fibonacci been plus one to computer. So it most and calls it will be exactly on calls that are not memorize those ones we have to pay for. How much do I have to pay? Well, if you don't count the recursion, which is what this recurrence does Persian, then the total amount of work done here is constant. Hey, so I will say is the non-recursive work. Her call is constant. And therefore I claim that the running time is constant linear. Carson would be pretty amazing. This is actually not the best algorithm to decide the best dog in the fog Computing and Fibonacci number uses long and operation so you can do better. But if you want to see that you should text except for 6. Okay, we're just going to get to linear today, which is a lot better than exponential. So why linear because there's and non-member wise calls and each of them cost constant? So the product of those two numbers. this is an important idea and so important I am going to write it down again. And it's slightly more General framework in general. and dynamic programming I didn't say why it's called memorization. You have this memo pad where you write down all your scratch work. That's this memo dictionary and to memorize is to write down on your memo pad. I didn't make it up another crazy term. It means remember. And then you remembered all the solutions that you've done and then you reuse those Solutions. Family Solutions are not really a solution to the problem that I care about. The problem I care about is Computing the nth Fibonacci number to get there. I had to compute other Fibonacci numbers cuz I had a recursive formulation. This is not always the way to solve the problem. But usually when you're solving something you can split it in two parts into some problems with. They're not always of the same flavor is the original goal problem, but there's some kind of related parts and this is the the big challenge in designing a dynamic program is to figure out what are the some problems but they always the first thing I want to know about a dynamic program is what are the sub problems? Somehow they are designed to help solve your actual problem. And the idea of memorization is once you solve a sub problem write down the answer if you ever need to solve that same some problem again, you reuse the answer. That is the core idea and Son distance dynamic programming is essentially recursion memorization. And so in this case, these are the same problems Fibonacci one through not even the one we care about is Fibonacci then but to get there we saw all these other stuff problems. In all cases if this is the situation so for any Dynamic program, the running time is going to eat equal to the number of different some problems. You might have to solve or that you do song. Pi times the amount of time you spend per sub problem. In this situation we had and some problems and for each of them we spent constant time and when I measure the time for some problem which in the Fibonacci case, I claim is constant. I ignore recursive calls. That's the key. We don't have to solve recurrence without any programming. count the Persians obviously don't count memorized recursions. The reason is I only need to count them. Once after the first time I do it it's free. So I count how many different some problems do I need to do these are they going to be the expensive recursions? Why do work I do some amount of work, but I don't count the recursions cuz otherwise I'd be double-counting only one account if some problem once and that it's all so simple idea in general dynamic programming a super simple idea. It's nothing fancy. There is one extra check for going to pull out but that's the idea. Alright, let me tell you. another perspective This is the one maybe most commonly taught. Esther think of that. I'm not a particular fan of it. I really like them was a she and I think it's a simple idea. And as long as you remember this formula here, it's really easy to work with. How about some people like to think of it this way? And so we can pick whichever way you find most intuitive instead of thinking of recursive algorithm which in some sense starts at the top of the big have what you want to solve and works its way down. You can do the reverse you can start at the bottom and work your way up and this is probably how you normally think about Computing Fibonacci numbers or how you learned it before. I'm going to write it in a slightly funny way. The point I want to make is that the transformation I'm doing from the naive recursive algorithm to the memorized algorithm to the bottom is completely automated. I'm not thinking I'm just doing is easy. This card is exactly the same as this code. And is that code except I replace the End by K. Just cuz I need a couple of different and valleys here or I want to enter eight over and values. And then there's this stuff around that code which is just formulaic. I thought goes into this for Loop, but that's it. And the Stars exactly the same thing as the memo is algorithm. Maybe takes a little bit of thinking to realize if you unroll all the recursion that's happening here and just write it out. Sequentially. This is exactly what's happening. Cuz this code does exactly the same editions exactly the same computations as this the only difference is how you get there here. We using a loop here we using recursion, but the same things happen in the same order. Really? No difference between the cut this cuz probably going to be more efficient and practice because you don't make function calls so much. In fact, I was not a function call to look up into a table using a hash table to be simple. But of course you can use an array but they're both constant. I'm alright, so is it clear with this is doing I think so. I think I made a little So we have to compute. F12 F and which one is that? And now we compute it exactly how we used to accept now instead of her cursing. I know that when I'm Computing the case of an option number because they're laughing number. I know that I've already computed the previous two. Why because I'm doing them in increasing order nothing fancy and then I can just do this and this solutions will just be waiting there if they weren't and get a key here. So I know that there's a bug but in fact I won't get a key or I will have always computer these things already. That I stored in my table, then I iterate eventually I saw the all the some problems f13 FN and the one I cared about was the Antoine. queso straightforward I'm do this cuz I don't really want to have to go through this transformation for every single problem. We do or doing any Fibonacci cuz it's super easy to write the code out explicitly, but you can do it for all of the dynamic programs that we cover in the next four lectures. Okay. I'm going to give you now the general case. This was the special Fibonacci version in general the bottom up does exactly the same competition as the memorize version. And what we're doing is actually a topological sort. Some problem. Dependency Dag. So in this case the dependency tag is very simple in order to compute an FN - 2i can do if I know those I can compute then there is FN - 3 which is necessary to complete this one and see what this bag looks like drana conveniently. So all the edges go left to right. So this is a topological order from left to right and so I just need to do F1 F2 FN in order. Hey, usually it's totally obvious what order to solve some problems in but in general what we what you should have in mind is that we are doing a topological sort here. We just did it cuz it's so easy and usually it's so easy. It's just a for Loop nothing fancy. All right. singing arrow Let's do something a little more interesting Shelly. I one thing you can do from this bottom-up perspective is you can save space. storage space in the oven I don't usually worry about space in his class, but it matters in reality. So here we're building a table size end. But in fact, we really only need to remember the last two values. So you can just store the last two values in the each time. You make a new one. Delete the oldest. So by thinking a little bit here you realize you only need constant space still linear time in space. And that's it. That's often the case from the bottom up perspective. You see what you really need to store what you need to keep track of. Alright, I guess another nice thing about this perspective is the running time is totally obvious or this is clearly constant. I'm so this is clearly linear time. Whereas in this memo you have to think about When's it going to be memorize when's it's not I still like this perspective because with this rule just multiply number so Problems by time for some problem you get the answer, but it's a little less obvious that Anna. Been cold like this. So choose. However you like to think about it. We move onto shortest paths. So I'm again as usual thinking about single-source shortest paths. So you want to compute the shortest path weight from s to be for all the hey, I'd like to write this. Initially as a naive recursive algorithm, which I can then memorize which I can then bought them up if I I just made that up. So, how can I write this as a naive recursive algorithm? So obvious? Hey, bud. First I'm going to tell you how just as an oracle tells you here's what you should do. But then we're going to think about go back step back. But actually I mean it's up to you. I can tell you the answer and we can figure out how we got there or we can just figure out the answer. preferences figure it out. No Divine inspirational ass so let me give you a tool. Tool is guessing. Cat sound silly, but it's a very powerful tool. General idea is suppose you don't know something, but you'd like to know it. Satellite Lena, what's the answer this question? I don't know and I really want to question. How am I going to answer the question? Yes, okay. It's head tried-and-tested method for solving any problem. I'm laboring the point here at concept is don't just try any guess try them all. cast of I said that simple tryall guesses This is Central to the programming. I know it sounds obvious. But if I want to fix my equation here. Dynamic programming is roughly recursion + memorization. There should really be plus guessing. memorization which is obvious guessing which is obvious are the central concept 2 dynamic programming trying to make it sound easy because usually people have trouble Try all the guests that something a computer can do great. This is the Brute Force part. Okay, but we're going to do it carefully. Knock knock that carefully. I mean, we're just trying all the gases take the best one. That's kind of important that we can choose one to be called best. That's why dynamic programming is good for optimization problems. When I Max my something to my something you try them all and then you can forget about all of them and just reduce it down to one thing, which is the best one or a best one. Okay. So now I want you to try to apply this principle to shortest paths now. I'm going to draw a picture which may help. have a source s Where's somewhere text me we like to find the shortest a shortest path from s to be at suppose. I want to know what the shortest path is supposed to this was it? have an idea What do you do? Where you can go. Got it, so I can look at all the places I can go from ass and then look at the shortest path from there to be so we can call this a prime. So here's the idea. There's some hypothetical shortest-path. I don't know where it goes first. So I will guess where it goes first. I know the first Edge must be one of the outgoing I just format so I don't know which one try them all. Very simple idea then for me to those if somehow I can compute the shortest path from there to me. Just do that and take the best choice for what that first Edge was. So this would be me guess first Edge approach. That's a very good idea. Not quite the one I want it because unfortunately that changes s answer this would work. It would just be slightly less efficient. If I'm solving single-source shortest paths by guessing the last Edge instead of the first day there really a cool one. If I was doing this side essential to be solving single-target shortest path, which we talked about. Before so, I'm going to draw the same picture. I want to get the V. I'm going to guess the last Edge call it UV. I know it's one of the incoming edges to be. Unless equals B. Then there's a special case as long as this passes linked at least one. There's some last Edge. What is it? I don't know guess guess all the possible incoming edges to V. And then recursively compute the shortest path from s to you and then add on the edge B. Peso what is the shortest path? It's Delta of s, u which is looks the same as another some problem that I want to solve their visa problems here I care about so that's good. I take that I add on the weight of the edge UV. And that should hopefully give me Delta a mess, be well if I was lucky and I guess the right choice of you in reality. I'm not lucky so I have to minimize. overall edges UV so this is the word minimizing over the choice of UV is already given here. So I take the minimum overall edges of the shortest path from SD you plus the weight of the SUV Patrick. Give me the shortest path cuz this gave me the shortest path from s to you then I added on the edge I need to get there and wherever the shortest path is, it has some and use the sun last ngv. There's got to be some first of you that's the right one. That's the that's the good guess that we're hoping for. We don't know what the good guesses. So we just try them all but whatever it is, this will be the weight of that pass going to take the best path from s to you because sometimes the shortest has the shortest structure. So this part will be dealt. So that's you this part is obviously wfuv. So this will give the right answer. hopefully certainly going to I mean, this is the analog of the naive recursive algorithm for Fibonacci. So it's not going to be efficient. If I mean, this is an algorithm right you could say this is a recursive call. I treat this as recursive call. instead of just a definition then this is a recursive algorithm. How good or bad is this recursive algorithm? Terrible Target very bad. Definitely going to be exponential. Without memorization, but we know we know how to make alkanes better. We memorize I think you know how to write this as a man wise algorithm to define the function Delta of SV. First check is s, v in the memo table. If so return that value. Otherwise do this computation with this is a recursive call and then stored in the memory table. Okay, I don't think I need to write that down. So just like the memorize code over there just there's not to argue instead of want. in fact SS and changing so I only need to store with v, t Is that a good algorithm? I claim my position makes everything faster. Is that a fast algorithm? That's why I guess I guess. Yes, how many people think? Yes. It's a good over there. Better feeling better. Can't be worse. How many people think it's a bad out in them. including the S boats good All right. It's not such a key. Let me dry you a graph. Something like that. So we wanted to come in Delta S, V. I think of these guys names A&B. So we compute Delta S, V to compute that we need to know Delta of S, A & S, be at those are the two ways. Actually we just need one. Only one incoming Edge to be so it's Delta of ass, Sorry, I should have put a better bass case here to Delta equals 0. Okay. The best, and plus the edge and there's some shortest path to I want to compute the trespass from me. I don't know there's two ways to get to be one of them is Delta s, be Sorry SMS came from s the other way is Delta of s, v. Just Your Problem Yeah, she trying to figure out. Thought you might say. Oh, it's okay because we're going to memorize or answer is Belfast, me and then we can reuse it here except we haven't finished Computing Delta S, V we can only put it in the memo table once we're done. So at this one s call happens remember tables not been set and we're going to do the same thing over and over and over again. This is an infinite algorithm. Oops, not so hot. So it's going to be internet. time on grass recycles If your dad's are you sick with graphs? It actually runs Envy pussy time. This is the case in this situation we can use this formula. The time is equal to the number of star problems X the time purse problem. So I guess we have to think about that a little bit. Where's my code? Here's my code number of some problems is V is be different some problems that I'm using here. I'm always raising some problems out the form Delta s, something but something could be any of the V vertices how much time do I spend per sub problem? It's a little tricky. The number of incoming edges to me. So time for sub problem. Delta MSP Is the in degree? The number of incoming I just to be so I just depends on peace so I can't just take a straight for a product here. But this is really saying is you should sum up overall subproblems of the time personal problem. so total time and some of Robin me in degree V and we know this is Number mattress that's really some in degree + 1 + 3 + 1 so this is hey, I'm shaking one again. Okay. Now we already knew and I were the four shortest paths in bags and it ran if he plus he time so it's another way to do the same thing. If you think about it long enough this algorithm memorize is essentially doing a depth-first search to do a topological sort to run one round of bellman-ford. So we've had topological sort plus one round of this is kind of it all rolled into one. This should look kind of like the Bellman Ford relaxation step or short as bad as relaxation step it is this man is really doing the same thing. So it's really the same time but we come at it from a different perspective. Okay, but I claim I can use the same approach to solve shortest paths in general grass, even when they have Cycles. How am I going to do that? bag seem fine What was the lesson learned here lesson learned? Is that some problem? tendencies Should be a cyclic. Otherwise we get an infinite algorithm for memorization to work. This is what you need all you need. Hey, we almost seen this already because I said that to do bottom up algorithm. You do a topological sort of the sun problem. Dependency dag. I already said it should I forgot I didn't tell you yet. So for that to work, it better be a cichlid for DP to work for memorization to work. It better be a cyclic if you're a cyclic then this is the running time. So that's all General. So somehow I need to take a cyclic graph and make it a cyclic. He's actually done this already in recitation. So if I have a graph? Let's just take a very simple cyclic graph. Hey one thing I can do is explode it into multiple layers who did the sun Quiz 2 and various forms. It's like the only cool thing you want to make us for his mouth from harder require that you reduce your graph to take copies of the graph. I'm going to do it in a particular way. Which is the think of this axis as time or however you want and make all of the edges go from each layer to the next layer. And it should be a familiar technique is every time I go down to the next layer. This makes any graph a cyclic done. What in the world is does this mean what is it doing? Does it mean double rainbow? All right, so I used to be my favorite. Here's what it means Delta sub k s v i got to Define this first. This is a new kind of some problem. Which is what is the shortest? What's the weight of the shortest? Destiny path but uses at most K address So I wanted to be sure to sometimes a total weight, but I also wanted to ask you I just total so this is going to be zero sense if you look at so here is his ass and always going to make ask this and then this is going to be V in the zero situation is going to be V in the one situation be so if I look at this fee, I look at the trespass from s2v. That is Delta Sub-Zero Sub-Zero. Patriots path from here to here is the there's no way to get there until Reggie shortest path from here to hear. That's this the best way to get there with that most 1-inch trespassed from here to hear some vertical itis to I guess cheating a little bit then this is the best way to get from s to be using at most two edges and then you get a recurrence. Does the man of raw last stages? So just copying that recurrence, but realizing that the PS2 u-part uses one fewer Edge and then I use the SUV. That's our new recurrence by adding this K parameter. I've made this recurrence on some problems a cyclic unfortunately have increase the number of subproblems number of some problems. now is B squared? technically three times be minus one cuz I really and what I care about but my goal. Is Delta Savvy - 1 SV because my bellman-ford analysis. I know that I only care about simplepass as a like that must be mad if I'm assuming here. No negative weight Cycles said that earlier you soon that then this is what I care about. So K ranges from 0 to be minus one. So there be choices for cat their V choices for V so number so problems is B squared how much time do I spend for? Some problem was same as before the in degree? Can I write a peer be in degree of that problem? So what I'm really doing is summing overall V the in degree, and then I x v so the running time total running time is VE. Sound familiar. This is Bellman Ford algorithm again, and this is actually we're bellman's for Bellman Ford. Algorithm came from is this view on dynamic programming so is him yet another way to do Bellman Ford may seem familiar, but in the next three lectures were going to see a whole bunch of problems that can succumb to the same approach super cool.